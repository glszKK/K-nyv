<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Schwarzenegger!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Szoftmax Py MNIST</title>
        <para>
            Python
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/j7f9SkJR3oc">https://youtu.be/j7f9SkJR3oc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0">https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0</link> (/tensorflow-0.9.0/tensorflow/examples/tutorials/mnist/), <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol</link>  
        </para>
        <para>
            A programot a Google hozta létre, mégpedig azért hogy a számítógépes tanulást fejlesszék és segítsék.
            És hogy a saját tanulmányaikat is segítsék mivel adatáramlási gráfot készít a program.
            A program lényege az hogy a megadott képen lévő számot felismerje, amire meg kell tanítanunk a programunkat.
            Létrehozunk egy modelt amin a programunk gyakorolni fog. Majd lefuttatunk egy próba kört ahol a program kiírja a becsült 
            pontosságot. Ezután a 42-es tesztkép felismerése következik. Legvégül a beolvasott képünkön teszteljük a működést.
            A W változó segítségével dönt arról hogy a kép amit megadtunk jó halmazban van e. Az x jelenti a bemenő értéket az y pedig a kimenő értéket.
            A tanulási folyamat is a neurális and or xor kapuhoz hasonló, ugyan úgy vannak hidden rétegek és nekik vannak 
            node-jai. X a példa és Y a várt eredmény. A tanulánál ugyan úgy iterációs határt számolunk. Az Y értékét úgy számoljuk 
            mintha egy egyenes egyenletét írnánk fel az Y= x*a súlyjal ami a W és hozzá adjuk a b-t ami a kostants.
           </para>
           <programlisting><![CDATA[
            y = tf.matmul(x, W) + b
       ]]>
        </programlisting>
            <para>
            Ez az egyenes az ami elválasztja a jó megoldásokat a rosszaktól. Vagyis amelyik teljesíti a feltételt és megközelítőleg helyes értéket ad.
            Itt a feladatunkban az elfogadási arányt(iterációs határ,gradient) 50% nál húztuk meg tehát a program hibázhat. A pontosságot minél több hidden réteggel és noda-al tudjuk növelni. Tehát az egész egy valószínűségi értéket figyel ha megüti a meghatározott küszöböt ez az érték és a hiba mértéke kevés akkor a program elfogadja mint megoldást. A programmal 28*28 pixeles képekről döntjük el, hogy milyen szám szerepel a képen. A y_ a loss-t definiáljuk, amely azt számolja,hogy mennyire térünk el a a várt eredményünktől. A GradientDescentOptimizer deriváltakat számít a hibahatárok figyelembe vételével. Ez a minimize.
                
            </para>
        
    </section>        

<!--
    <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
    
    <section>
        <title>Mély MNIST</title>
        <para>
            Python            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            
            Megoldás forrása:<link xlink:href="https://github.com/tensorflow/tensorflow/tree/r1.4/tensorflow/examples/tutorials/mnist">https://github.com/tensorflow/tensorflow/tree/r1.4/tensorflow/examples/tutorials/mnist</link>            
        </para>
        <para>
            Ez a feladat hasonló az előzőhöz, 2 layer-el dolgozunk, a második layerünk az első által kiszámolt adatokból dolgozik így 
            növelve a program pontosságát. Emellett több a hidden réteg és a node-ok száma is. Itt neuronokól beszélünk, amiknek 
            két állapota van, vagy aktívak vagy pedig nem. Vagyis inkább vagy aktív, hisz mindig csak egyetlen egy neuron lehet aktiválva 
            ha több van megkell keresnünk a legpontosabbat. Amit akkor kapunk meg ha a pontosságunk a legnagyobb és a hibavisszaterjesztésnél
            (amit ellenőrzésre használunk) a loss a legkisebb. És már nem csak számokat képes felismerni hanem igazából bármit amit megadunk az 
            adatbázisban, jelen esetben 32x32 képet vizsgálunk. És a reshape a bemeneti 2D kép pixeleit átrendezi egy egy soros listába ami
            azért kell hogy a program tudja vizsgálni a pixeleket.
        </para>
                   <programlisting><![CDATA[
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import argparse
import sys
import tempfile

from tensorflow.examples.tutorials.mnist import input_data

import tensorflow as tf

FLAGS = None


def deepnn(x):
  """deepnn builds the graph for a deep net for classifying digits.
  Args:
    x: an input tensor with the dimensions (N_examples, 784), where 784 is the
    number of pixels in a standard MNIST image.
  Returns:
    A tuple (y, keep_prob). y is a tensor of shape (N_examples, 10), with values
    equal to the logits of classifying the digit into one of 10 classes (the
    digits 0-9). keep_prob is a scalar placeholder for the probability of
    dropout.
  """
  # Reshape to use within a convolutional neural net.
  # Last dimension is for "features" - there is only one here, since images are
  # grayscale -- it would be 3 for an RGB image, 4 for RGBA, etc.
  with tf.name_scope('reshape'):
    x_image = tf.reshape(x, [-1, 28, 28, 1])

  # First convolutional layer - maps one grayscale image to 32 feature maps.
  with tf.name_scope('conv1'):
    W_conv1 = weight_variable([5, 5, 1, 32])
    b_conv1 = bias_variable([32])
    h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)

  # Pooling layer - downsamples by 2X.
  with tf.name_scope('pool1'):
    h_pool1 = max_pool_2x2(h_conv1)

  # Second convolutional layer -- maps 32 feature maps to 64.
  with tf.name_scope('conv2'):
    W_conv2 = weight_variable([5, 5, 32, 64])
    b_conv2 = bias_variable([64])
    h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)

  # Second pooling layer.
  with tf.name_scope('pool2'):
    h_pool2 = max_pool_2x2(h_conv2)

  # Fully connected layer 1 -- after 2 round of downsampling, our 28x28 image
  # is down to 7x7x64 feature maps -- maps this to 1024 features.
  with tf.name_scope('fc1'):
    W_fc1 = weight_variable([7 * 7 * 64, 1024])
    b_fc1 = bias_variable([1024])

    h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64])
    h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)

  # Dropout - controls the complexity of the model, prevents co-adaptation of
  # features.
  with tf.name_scope('dropout'):
    keep_prob = tf.placeholder(tf.float32)
    h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)

  # Map the 1024 features to 10 classes, one for each digit
  with tf.name_scope('fc2'):
    W_fc2 = weight_variable([1024, 10])
    b_fc2 = bias_variable([10])

    y_conv = tf.matmul(h_fc1_drop, W_fc2) + b_fc2
  return y_conv, keep_prob


def conv2d(x, W):
  """conv2d returns a 2d convolution layer with full stride."""
  return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')


def max_pool_2x2(x):
  """max_pool_2x2 downsamples a feature map by 2X."""
  return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],
                        strides=[1, 2, 2, 1], padding='SAME')


def weight_variable(shape):
  """weight_variable generates a weight variable of a given shape."""
  initial = tf.truncated_normal(shape, stddev=0.1)
  return tf.Variable(initial)


def bias_variable(shape):
  """bias_variable generates a bias variable of a given shape."""
  initial = tf.constant(0.1, shape=shape)
  return tf.Variable(initial)


def main(_):
  # Import data
  mnist = input_data.read_data_sets(FLAGS.data_dir, one_hot=True)

  # Create the model
  x = tf.placeholder(tf.float32, [None, 784])

  # Define loss and optimizer
  y_ = tf.placeholder(tf.float32, [None, 10])

  # Build the graph for the deep net
  y_conv, keep_prob = deepnn(x)

  with tf.name_scope('loss'):
    cross_entropy = tf.nn.softmax_cross_entropy_with_logits(labels=y_,
                                                            logits=y_conv)
  cross_entropy = tf.reduce_mean(cross_entropy)

  with tf.name_scope('adam_optimizer'):
    train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)

  with tf.name_scope('accuracy'):
    correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))
    correct_prediction = tf.cast(correct_prediction, tf.float32)
  accuracy = tf.reduce_mean(correct_prediction)

  graph_location = tempfile.mkdtemp()
  print('Saving graph to: %s' % graph_location)
  train_writer = tf.summary.FileWriter(graph_location)
  train_writer.add_graph(tf.get_default_graph())

  with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    for i in range(20000):
      batch = mnist.train.next_batch(50)
      if i % 100 == 0:
        train_accuracy = accuracy.eval(feed_dict={
            x: batch[0], y_: batch[1], keep_prob: 1.0})
        print('step %d, training accuracy %g' % (i, train_accuracy))
      train_step.run(feed_dict={x: batch[0], y_: batch[1], keep_prob: 0.5})

    print('test accuracy %g' % accuracy.eval(feed_dict={
        x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0}))

if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('--data_dir', type=str,
                      default='/tmp/tensorflow/mnist/input_data',
                      help='Directory for storing input data')
  FLAGS, unparsed = parser.parse_known_args()
  tf.app.run(main=main, argv=[sys.argv[0]] + unparsed)
       ]]>
        </programlisting>
    </section>        
<!--
    <section>
        <title>Deep dream</title>
        <para>
            Keras            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->                  
    <section>
        <title>Minecraft-MALMÖ</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>      
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/Microsoft/malmo">https://github.com/Microsoft/malmo</link>                
        </para>
        <para>
            A világ egyik leghíresebb játékáról lesz most szó, a Minecraftról. 
            A microsoft által készített program lényege az hogy a karakterünk akit Steve-nek hívnak
            egy megadott időlimiten belül ne menjen neki semminek és ne akadjon el semmiben.
            Tehát vagy kikerülje azokat vagy elrombolja. Steve körül 26 kockát vizsgálunk. A karakterünk elindul és ha akadályba
            ütközik először megpróbálja kikerülni, ha ez nem lehetséges akkor az ugrást próbálja meg. Az akadályok lehetnek
            különféle növényzet vagy akár víz vagy láva is. A rombolás meg csak akkor jön létre ha 2 blocknál magasabb az adott akadály
            hisz a minecraftba már 2 block magasra nem tudunk ugrani, így a karakterünk kénytelen elrombolni azokat a blockokat a továbbjutáshoz.
        </para>
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
</chapter>                      
