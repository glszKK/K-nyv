<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
	    Az első feladatban három egyszerű végtelen ciklust kell létrehoznunk, az elsőben egy olyat ami 0 százalákban dolgoztatja a magot:
        </para>
	<programlisting language="c"><![CDATA[
		#include <unistd.h>
                 int
                 main ()
                 {
                 for (;;)
                 sleep (1);
                 return 0;
                 }
 
]]></programlisting> 
	    
        <para>
           A második feladatban azt kell elérnünk hogy 100 százalékban dolgozzon a mag:		
        </para>
	<programlisting language="c"><![CDATA[
		#include <unistd.h>
                int
                main ()
                {
                for (;;){}
                return 0;
                }
             
]]></programlisting> 
	    
	<para>
            A feladat harmadik részében pedig azt kell elérnünk hogy a gépünk összes magja 100 százalékon dolgozzon, ehhez először utána kell járnunk
            annak hogy hány magos is a gépunk. Ha ez megvan utána neki kezdhetünk a feladatnak, ami annyiban változik a második feladat-tól hogy 
            annyi új threadot kell nyitnunk ahány magos a számítógépünk.
        </para>
	<programlisting language="c"><![CDATA[
		#include <unistd.h>
                int main ()
                {
                   int p1, p2, p3;

                   if(!(p1 = fork()))
                   {
                       for( ;; );
                   if(!(p2 = fork()))
                   {
                       for( ;; );
                   if(!(p3 = fork()))
                   {
                       for( ;; );
                }
                for (;;){}
                return 0;
                }
     
]]></programlisting> 
       </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
           A második feladatban azt kell megmutatnunk hogy tudunk-e olyan programot írni amely el tudja dönteni egy adott programról hogy le fog-e fagyni vagy sem. 
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
            {
	    boolean Lefagy(Program P)
	    {
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	    }
	    main(Input Q)
	    {
		Lefagy(Q)
	    }
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{
	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}
	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}
	main(Input Q)
	{
		Lefagy2(Q)
	}
}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
	<para>
	Sajnos olyan programot kéne ehhez írnunk ami segít megmutatni hogy a fenti program jól fut e vagy sem, ami lehetetlen.
	</para>	
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
	    Harmadik feladat, itt egy olyan C programra lesz szükségünk amely felcseréli két változó értékét, bármiféle logika utasítás vagy kifejezés
            használata nélkül.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
	<programlisting language="c"><![CDATA[
		#include<stdio.h>
		int main()

		{
		
                int valtozo_1 = 2,valtozo_2 = 4;
		 printf("valtozo_1=%d valtozo_2=%d\n",valtozo_1,valtozo_2);
			
		  valtozo_1 = ( valtozo_1 - valtozo_2 );
		  valtozo_2 = ( valtozo_1 + valtozo_2 );
		  valtozo_1 = ( valtozo_2 - valtozo_1 );
		 printf("valtozo_1=%d valtozo_2=%d\n",valtozo_1, valtozo_2);
		return 0;
		}             
]]></programlisting> 
	<para>
            Megoldás forrása segédváltozóval:
        </para>
	<programlisting language="c"><![CDATA[
		int main()
		{			
			int v1=1, v2=2, v3;
			v3=v1;
			v1=v2;
			v2=v3;
			return 0;
		}             
]]></programlisting>
        <para>
		A csere segédváltozóval bevezet egy új ideiglenes változót, amiben az eslő változó értékét tároljuk amíg abba belereakjuk a 2. változó értékét
		mert ekkor a v1 értéke elvész. Ezután a második változóba belerakjuk a segédváltozóban eltárolt eslő változó értékét.
        </para>
	<para>
		Segédváltozó nélküli csere csak egyszerű kivonás meg osszeadás.
	</para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            A negyedik feladatban legy olyan programot kell létrehoznunk mely egy labdát pattogtat a karakteres konzolon, először if-ekkel, majd utána bármi féle logika utasítás
            vagy kifejezés használata nélkül.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/ujhazibalazs/MagProg1/blob/master/labdapattogas.cpp">https://github.com/ujhazibalazs/MagProg1/blob/master/labdapattogas.cpp</link>
        </para>
	<programlisting language="c"><![CDATA[
#include <stdio.h>
#include <curses.h>
#include <unistd.h>

int
main ( void )
{
    WINDOW *ablak;
    ablak = initscr ();

    int x = 0;
    int y = 0;

    int xnov = 1;
    int ynov = 1;

    int mx;
    int my;

    for ( ;; ) {

        getmaxyx ( ablak, my , mx );

        mvprintw ( y, x, "O" );

        refresh ();
        usleep ( 100000 );

        x = x + xnov;
        y = y + ynov;

        if ( x>=mx-1 ) { // elerte-e a jobb oldalt?
            xnov = xnov * -1;
        }
        if ( x<=0 ) { // elerte-e a bal oldalt?
            xnov = xnov * -1;
        }
        if ( y<=0 ) { // elerte-e a tetejet?
            ynov = ynov * -1;
        }
        if ( y>=my-1 ) { // elerte-e a aljat?
            ynov = ynov * -1
        }

    }

    return 0;
}
]]></programlisting>
        <para>
            Ez a program eltér az előzőektől egy minimálisan, hisz itt új header fileokat használunk. Melyeknek a neve curses.h és unistd.h.
            Ezek segítségével tudjuk a kurzort mozgatni a terminálon belül.
        </para>
     </section>   
	
   <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
	   Az ötödik feladatban olyan programot kell írnunk amely azt nézi meg, hogy hány bites a szó a gépeden,
           azaz mekkora az <type>int</type> mérete. Azt a while ciklust kell használnunk amit Linus Torvalds a BogoMIPS rutinjában használtt.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/kezdo/elsoc/szohossz/szohossz.c#l4">https://sourceforge.net/p/udprog/code/ci/master/tree/source/kezdo/elsoc/szohossz/szohossz.c#l4</link>
        </para>
	<programlisting language="c"><![CDATA[
		#include <stdio.h>
		int
		main (void)
		{
 		 int h = 0;
 		 int n = 0x01;
 		 do
 		   ++h;
 		 while (n <<= 1);
 		 printf ("A szohossz ezen a gepen: %d bites\n", h);
 		 return 0;
		}            
]]></programlisting>
        <para>
	A Linus Torvalds féle while ciklus igazán egyszerű, csak addig kell shiftelnünk a biteket, míg eredményül nullát nem kapunk.	    
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Hatodik feladat, itt egy olyan programra lesz szükségünk, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét.
       </para>
<programlisting language="c"><![CDATA[
		#include <stdio.h>
#include <math.h>

void
kiir (double tomb[], int db){
	
	int i;
	
	for (i=0; i<db; ++i){
		printf("%f\n",tomb[i]);
	}
}

double
tavolsag (double PR[], double PRv[], int n){
	
	int i;
	double osszeg=0;
	
	for (i = 0; i < n; ++i)
		osszeg += (PRv[i] - PR[i]) * (PRv[i] - PR[i]);
	
	return sqrt(osszeg);
}

void
pagerank(double T[4][4]){
	double PR[4] = { 0.0, 0.0, 0.0, 0.0 }; //ebbe megy az eredmény
	double PRv[4] = { 1.0/4.0, 1.0/4.0, 1.0/4.0, 1.0/4.0}; //ezzel szorzok
	
	int i, j;
	
	for(;;){
		
		// ide jön a mátrix művelet		
		
		for (i=0; i<4; i++){
			PR[i]=0.0;
			for (j=0; j<4; j++){
				PR[i] = PR[i] + T[i][j]*PRv[j];
			}
		}
	
			if (tavolsag(PR,PRv,4) < 0.0000000001) 
				break;
		
		// ide meg az átpakolás PR-ből PRv-be
			
			for (i=0;i<4; i++){
				PRv[i]=PR[i];
			}	
	}
	
	kiir (PR, 4);
}

int main (void){
	double L[4][4] = {
		{0.0,  0.0,      1.0/3.0,  0.0},
		{1.0,  1.0/2.0,  1.0/3.0,  1.0},
		{0.0,  1.0/2.0,  0.0,      0.0},
		{0.0,  0.0, 	 1.0/3.0,  0.0}
	};	
	
	double L1[4][4] = {
		{0.0,  0.0,      1.0/3.0,  0.0},
		{1.0,  1.0/2.0,  1.0/3.0,  0.0},
		{0.0,  1.0/2.0,  0.0,      0.0},
		{0.0,  0.0, 	 1.0/3.0,  0.0}
	};
	
	double L2[4][4] = {
		{0.0,  0.0,      1.0/3.0,  0.0},
		{1.0,  1.0/2.0,  1.0/3.0,  0.0},
		{0.0,  1.0/2.0,  0.0,      0.0},
		{0.0,  0.0, 	 1.0/3.0,  1.0}
	};
	
	printf("\nAz eredeti mátrix értékeivel történő futás:\n");
	pagerank(L);
	
	printf("\nAmikor az egyik oldal semmire sem mutat:\n");
	pagerank(L1);
	
	printf("\nAmikor az egyik oldal csak magára mutat:\n");
	pagerank(L2);
	
	printf("\n");

	return 0;
}

]]></programlisting>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nohar92/bhax/blob/master/Harmati%20Norbert/1.%20rész/pagerank.c"></link>
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
	    A hetedik feladatban R szimulációt kell írnunk a Brun tétel demonstrálására.
        </para>
<programlisting language="C"><![CDATA[
 stp <- function(x){

    primes = primes(x)
    diff = primes[2:length(primes)]-primes[1:length(primes)-1]
    idx = which(diff==2)
    t1primes = primes[idx]
    t2primes = primes[idx]+2
    rt1plust2 = 1/t1primes+1/t2primes
    return(sum(rt1plust2))
}

x=seq(10, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
		    
]]></programlisting>		    
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Az utolsó feladatban R szimulációt kell írnunk a Monty Hall problémára.
        </para>
<programlisting language="C"><![CDATA[
kiserletek_szama=100
kiserlet = sample(1:3, kiserletek_szama, replace=T)
jatekos = sample(1:3, kiserletek_szama, replace=T)
musorvezeto=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    if(kiserlet[i]==jatekos[i]){
    
        mibol=setdiff(c(1,2,3), kiserlet[i])
    
    }else{
    
        mibol=setdiff(c(1,2,3), c(kiserlet[i], jatekos[i]))
    
    }

    musorvezeto[i] = mibol[sample(1:length(mibol),1)]

}

nemvaltoztatesnyer= which(kiserlet==jatekos)
valtoztat=vector(length = kiserletek_szama)

for (i in 1:kiserletek_szama) {

    holvalt = setdiff(c(1,2,3), c(musorvezeto[i], jatekos[i]))
    valtoztat[i] = holvalt[sample(1:length(holvalt),1)]
    
}

valtoztatesnyer = which(kiserlet==valtoztat)


sprintf("Kiserletek szama: %i", kiserletek_szama)
length(nemvaltoztatesnyer)
length(valtoztatesnyer)
length(nemvaltoztatesnyer)/length(valtoztatesnyer)
length(nemvaltoztatesnyer)+length(valtoztatesnyer)

		    
]]></programlisting>	    
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
    </section>
</chapter>                
