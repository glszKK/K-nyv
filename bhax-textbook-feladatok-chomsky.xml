<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
	 A harmadik fejezet első feladatában mint már a címben is látható, Decimálisból unárisba átváltó Turing gépet kell létrehoznunk,
	 állapotátmenet gráfjával megadva.
        </para>
	<para>
            Megoldás forrása: <link xlink:href="https://github.com/glszKK/Chomsky/tree/master">https://github.com/glszKK/Chomsky/tree/master</link>
        </para>
	    
	<programlisting language="c"><![CDATA[
	#include <stdio.h>
	int main()
	{
	  int x;
	  printf("Tizes szamrendszerbeli szam:");
	  scanf("%d",&x);
	  printf("\nUnaris alakja:");
	  for(int i = 0; i < x; i++)
	    {
	      printf("/");
	    }
	  printf("\n");
	  return 0;
	}
	]]>
        </programlisting>
	    <mediaobject>
                <imageobject>
                    <imagedata fileref="img/turingép.png" scale="50" />
                </imageobject>
        </mediaobject>
       <para>
		A feladatban az unáris számrendszerről lesz szó, ami ugye tudjuk az egyes számrendszer. A programunk lényege
	       hogy decimálisból unárisba váltas át a számokat. Mindez úgy történik hogy folyamatosan kivonunk 1-et az átváltani
	       kívánt számból és ezeket a kivont 1-eseket tároljuk. Addig még 0-át nem kapunk eredményül. Ehhez egy for ciklust használunk.
        </para>
    </section>        
        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
  	<para>
            Megoldás forrása: <link xlink:href="https://github.com/glszKK/Chomsky/tree/master">https://github.com/glszKK/Chomsky/tree/master</link>
        </para>
	    <mediaobject>
                <imageobject>
                    <imagedata fileref="img/chomsky.png" scale="50" />
                </imageobject>
        </mediaobject>
	<para>
        	A generatív nyelvtan kitalálója, a fejezetünk névadója volt: Noam Chomsky. A neve ismert lehet még
		a Chomsky-hierarchiából is, ezt fentebb szúrtam be. A generatív nyelvtan a formális nyelvek közé tartozik
		aminek 2 másik fajtája is van, a környezetfüggetlen nyelvtan és a szabályos nyelvtan. Igy 3-an alkotják meg
		a Formális nyelveket. Mivel a feladatunk az hogy két példát mutassunk be a generatív nyelvre így
		allíthatjuk hogy nem környezettfüggetlen nyelvről beszélünk.
        </para>
	<para>    
		<programlisting language="c"><![CDATA[
  		S -> aBSc
		S -> abc
		Ba -> aB
		Bb -> bb
		S -> aBSc -> aBaBScc -> aBaBabccc -> aaBBabccc -> aaBaBbccc -> aaaBBbccc ->  -
		aaaBbbccc -> aaabbbccc	
	]]>
        </programlisting>
        </para>   
	<para>
		    <programlisting language="c"><![CDATA[
          	 S -> abc
		S -> aXbc
		Xb -> bX
		Xc -> Ybcc
		bY -> Yb
		aY -> aaX
		aY -> aa
		S -> aXbc -> abXc -> abYbcc -> aYbbcc->aXbbcc -> aabXbcc-> aabbXcc-> aabbYbccc -> aaYbbccc -> aaYbbbccc->aaabbbccc	
	]]>
        </programlisting>
	    </para>    
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
	<para>
            Megoldás forrása: <link xlink:href="https://github.com/glszKK/Chomsky/tree/master">https://github.com/glszKK/Chomsky/tree/master</link>
        </para>
	 <para>
            
		Ebben a részben a C nyelvről lesz szó. Mint tudjuk hisi nekünk is olvasnunk kell, létezik egy referencia könyv
		 ahol a C nyelvhesz szükséges információkat és utasításokat megtaláljuk. Ilyenek példál a szabványok. Amik
		 igazából mindig valami új featurest hoznak be a C nyelvbe. Csak a probléma az hogy visszafele nem futnak
		 és nem működnek az újabb szabványok. Példál van a C99 szabvány, amiben már lehet dekralálni viszont a C89-ben
		 még ez nem tud lefutni hisz ott még külön kellett dekralálni. A feladatunk az most hogy mutassunk kettő olyan kód
		 csipetet amivel betudjuk bizonyítani hogy visszafele nem fordulnak.
        </para>
	    <programlisting language="c"><![CDATA[
		int main(){
		//int a;
		return
	    ]]>
        </programlisting>
	  <para>
		Ilyen például a fenti kódcsipetünk, ez C99-be lefüt,C89-ben nem,mégpedig azért mert  megengedett a //-el való 
		  kommentelés viszont a C89-ben még nem.
	  </para>
	     <programlisting language="c"><![CDATA[
	    		#include <stdio.h>

			int main()
			{
			for(int a=5;a>10;a++);
			return 0;
			}
	       ]]>
        </programlisting>
	    <para>
		Itt pedig a leírásban említett dekralálás látható.
	  </para>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
	<para>
            Megoldás forrása: <link xlink:href="https://github.com/glszKK/Chomsky/tree/master">https://github.com/glszKK/Chomsky/tree/master</link>
        </para>
        <para>
		A programunk működése úgy néz ki hogy include-oljuk az stdio.h header filet és jelzem hogy en ezzel szeretnék dolgozni.
		Majd ezútán definiáljuk és írjuk le a lexer számlálót ami ugye számolni fogja a bemenetet betűként. A digit
		függvénnyel adjuk meg a számokat majd növeljük azokat egyesével. A következő sorba láthatjuk hogy milyen 
		karaktereket ismer fel [A-Za-z][A-Za-z0-9]. Aztán jön a feladatunk main része ahol meghívjuk az elemzőt
		ahogy a commentben is olvashatjuk, azaz a lexert (yylex). Majd kiírjuk az eredményt amit kaptunk.
		A returtn 0.-val pedig véget vetünk a programunknak.
        </para>
		 <programlisting language="c"><![CDATA[
		/*** definíciós rész ***/

		%{
		/* Ez a kód bemásolódik a generált C forrásba*/
		#include <stdio.h>
		int valos=0;
		%}

		/* Ez az opció azt mondja meg, hogy csak egy input file kerüljön beolvasásra. */
		%option noyywrap

		%%
 		/*** Szabályok ***/ 

	
		[:digit:]+  { valos++; }
		[A-Za-z][A-Za-z0-9]*       {   /* Minden más karaktert ignorálunk. */   }

		%%
		/*** C kód. Ez is bemásolódik a generált C forrásba. ***/

		int main()
		{
   		 /* Meghívjuk az elemzőt, majd kilépünk.*/
        	yylex();
		printf("%d valós számot talált a lexer: \n",valos);
   		 return 0;
		}
       ]]>
        </programlisting>
    </section>                     

    <section>
        <title>l33t.l</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
	<para>
            Megoldás forrása: <link xlink:href="https://github.com/glszKK/Chomsky/tree/master">https://github.com/glszKK/Chomsky/tree/master</link>
        </para>
        <para>
         
		
		
		
		
		

        </para>
    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
	<para>
            Megoldás forrása: <link xlink:href="https://github.com/glszKK/Chomsky/tree/master">https://github.com/glszKK/Chomsky/tree/master</link>
        </para>
            
        <orderedlist numeration="lowerroman">
            <listitem>                                    
                <programlisting><![CDATA[if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
    signal(SIGINT, jelkezelo);]]></programlisting>
		<para>
			Ha a SIGINT nem volt figyelmen kívül hagyva akkor a jelkezelő kezelje.
			Ha figyelmen kívül volt hagyva tövábbra is maradjon úgy.
		</para>
            </listitem>
	
            <listitem>                                    
                <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>  
		<para>
		A függvény 5x fog lefutni, viszont figyelni kell arra hogy az i változót még a for ciklus ellőtt deklarálni kell, és ha az i-t ++i-vel növeltük akkor lehetőleg 		továbbra is úgy használjuk hogy könnyebben érthető maradjon a kód.
	
		</para>          
            </listitem>
	
            <listitem>
                <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>  
		<para>
			Itt is ugyanaz igaz mint az előzőnél. A cuklus 5x le fog futni ha a ciklusváltozót deklarátuk a ciklus előtt.
		</para>          
            </listitem>
	
            <listitem>
                <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>  
		<para>
			Nyelvtani hiba nincs ha már létrehoztuk a tomb nevű tömböt és az i-t. Le is fog fordulni, viszont az eredmény bugos lesz.
		</para>          
            </listitem>
	
            <listitem>
                <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>
		<para>
			A kód hibamentes ha már létrehoztuk a látható változókat és mutatókat.
		</para>            
            </listitem>
	
            <listitem>
                <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>  
		<para>
			A printf függvény ki fog írni 2 decimális számot ha már megvan az f függvény, az a változó, és ha az a változó megfelelő típusú az f függvényhez.
			Arra kell figyelni hogy ha az f függvény visszatérési értéke nem int akkor a kiírt értékek nem biztos hogy pontosak lesznek.
		</para>          
            </listitem>
	
            <listitem>
                <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>  
		<para>
			A printf ki fogja írni az f függvény visszatérési értékét a-ra decimális alakban, és a értékét decimális alakban. Itt is ugyanarra kell figyelni mint 				az előbb. Nyelvtani hiba nincs a kódrészletben.
		</para>          
            </listitem>
	
            <listitem>
                <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>  
		<para>
		A kiiratás megtörténik viszont az f függvény most az a változó memória címévél fog dolgozni nem az a értékével ha ezt akarjuk akkor nincs semmi gond.
		</para>          
            </listitem>	
        </orderedlist>
        <para>
	    
		
		
		
        </para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$]]></programlisting>
	<para>
		Végtelen sok prím van.
	</para>
	<programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$]]></programlisting> 
	<para>
		Végtelen sok ikerprím van.
	</para>
	<programlisting language="tex"><![CDATA[$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $]]></programlisting> 
	<para>
		Véges sok prím van.
	</para>
	<programlisting language="tex"><![CDATA[$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$]]></programlisting>
	<para>
		Véges sok prím van.
	</para>
        
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>
	<para>
            Megoldás forrása: <link xlink:href="https://github.com/glszKK/Chomsky/tree/master">https://github.com/glszKK/Chomsky/tree/master</link>
        </para>

        <itemizedlist>
            <listitem>
                <para>egész</para>
		<programlisting><![CDATA[int a;]]></programlisting>                         
            </listitem>
            <listitem>
                <para>egészre mutató mutató</para>
		<programlisting><![CDATA[int *b;]]></programlisting>                        
            </listitem>
            <listitem>
                <para>egész referenciája</para>
		<programlisting><![CDATA[int &r;]]></programlisting>                        
            </listitem>
            <listitem>
                <para>egészek tömbje</para>
		<programlisting><![CDATA[int t[5];]]></programlisting>                        
            </listitem>
            <listitem>
                <para>egészek tömbjének referenciája (nem az első elemé)</para>
		<programlisting><![CDATA[int (&tr)[5] = t;]]></programlisting>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatók tömbje</para>
		<programlisting><![CDATA[int *d[5];]]></programlisting>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvény</para>
		<programlisting><![CDATA[int *h();]]></programlisting>                        
            </listitem>
            <listitem>
                <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>
		<programlisting><![CDATA[int *(*h) ();]]></programlisting>                        
            </listitem>
            <listitem>
                <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>
		<programlisting><![CDATA[int (*v (int c)) (int a, int b);]]></programlisting>
            </listitem>            
            <listitem>
                <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>
		<programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>                        
            </listitem>            
        </itemizedlist>            

       <para>
            Mit vezetnek be a programba a következő nevek?
        </para>

        <itemizedlist>
            <listitem>
                <programlisting><![CDATA[int a;]]></programlisting>   
		<para>
			Egy egész típusú változót.
		</para>         
            </listitem>

            <listitem>
                <programlisting><![CDATA[int *b = &a;]]></programlisting>
		<para>
			Egy egész típusú mutatót ami a-ra mutat.
		</para>            
            </listitem>

            <listitem>
                <programlisting><![CDATA[int &r = a;]]></programlisting>   
		<para>
			a változónak a referenciája.
		</para>         
            </listitem>

            <listitem>
                <programlisting><![CDATA[int c[5];]]></programlisting>  
		<para>
			Egy 5 elemű egész típusú tömböt.
		</para>          
            </listitem>

            <listitem>
                <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>    
		<para>
			Egészek tömbjének referenciáját.
		</para>        
            </listitem>
            <listitem>
                <programlisting><![CDATA[int *d[5];]]></programlisting>  
		<para>
			5 elemű int-re mutató mutatók tömbjét.
		</para>          
            </listitem>

            <listitem>
                <programlisting><![CDATA[int *h ();]]></programlisting> 
		<para>
			Egy függvényt ami int-re mutató mutatót ad vissza.
		</para>           
            </listitem>

            <listitem>
                <programlisting><![CDATA[int *(*l) ();]]></programlisting> 
		<para>
			Egy int-re mutató mutatót visszaadó függvényre mutató mutatót.(pl. az előző függvényre)
		</para>           
            </listitem>

            <listitem>
                <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>
		<para>
			int-et visszaadó, két intet kapó függvényre mutató mutatót visszaadó egészet kapó függvényt.
		</para>            
            </listitem> 
           
            <listitem>
                <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>  
		<para>
			int-et visszaadó, két intet kapó függvényre mutató mutatót visszaadó egészet kapó függvényre mutató mutatót.
		</para>          
            </listitem>            
        </itemizedlist>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>  
