<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>A Mandelbrot halmaz</title>
        <programlisting language="c"><![CDATA[
#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 1000000000;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }

  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      // k megy az oszlopokon

      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]></programlisting> 
        <para>
        Tanulságok, tapasztalatok, magyarázat...
        A Mandelbrot-halmaz a komplex számsíkon ábrázolva, fraktálalakzatot vesz fel.
        A fraktálok: végtelenül komplex geometriai alakzatok, két gyakori tulajdonsággal rendelkeznek: 
        Az első: A fraktálok határoló vonalai vagy -felületei végtelenül „gyűröttek” vagy „érdesek”, illetve „szakadásosak”.
        A második:  A rendkívül problematikus, de jól érzékelhető önhasonlóság.
        A Mandelbrot-halmazt Benoît Mandelbrot fedezte fel, és Adrien Douady és John Hamal Hubbard nevezte el róla 1982-ben.
         </para>
        <para>
            Megoldás forrása: https://github.com/ujhazibalazs/MagProg1/blob/master/3.1.2.cpp
        </para>
    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Megoldás forrása: https://github.com/ujhazibalazs/MagProg1/blob/master/mandelpng.cpp
        </para>
        <programlisting language="c"><![CDATA[
#include <iostream>
#include <png++/png.hpp>

int main (int argc, char *argv[])
{
    if (argc != 2) {
        std::cout << "Hasznalat: ./mandelpng fajlnev";
        return -1;
    }
    
    // számítás adatai
    double a = -2.0, b = .7,  c = -1.35, d = 1.35;
    int szelesseg = 600, magassag = 600, iteraciosHatar = 1000;
    
    // png-t készítünk a png++ csomaggal
    png::image <png::rgb_pixel> kep (szelesseg, magassag);
    
    // a számítás
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    // Hány iterációt csináltunk?
    int iteracio = 0;
    std::cout << "Szamitas";
    // Végigzongorázzuk a szélesség x magasság rácsot:
    for (int j=0; j<magassag; ++j) {
        //sor = j;
        for (int k=0; k<szelesseg; ++k) {
            // c = (reC, imC) a rács csomópontjainak
            // megfelelő komplex szám
            reC = a+k*dx;
            imC = d-j*dy;
            // z_0 = 0 = (reZ, imZ)
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            // z_{n+1} = z_n * z_n + c iterációk
            // számítása, amíg |z_n| < 2 vagy még
            // nem értük el a 255 iterációt, ha
            // viszont elértük, akkor úgy vesszük,
            // hogy a kiinduláci c komplex számra
            // az iteráció konvergens, azaz a c a
            // Mandelbrot halmaz eleme
            while (reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                // z_{n+1} = z_n * z_n + c
                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                
                ++iteracio;
                
            }
            
            kep.set_pixel(k, j, png::rgb_pixel(255-iteracio%256,
                                               255-iteracio%256, 255-iteracio%256));
        }
        std::cout << "." << std::flush;
    }
    
    kep.write (argv[1]);
    std::cout << argv[1] << " mentve" << std::endl;
}
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Az előző feladatot fogjuk megoldani, csak most egy kicsit másképpen. Ahogy láttad,
            az előbb a komplex számokat két változóban tároltuk, egyikben a valós, ,másikban
            pedig a képzetes részét. De az infromatikusok lusták, mindek használnánk 2
            változót, ha lehet egyet is. Ezt teszi számunkra lehetőve a <function>complex</function>
            library, melynek segítségével a gép képes kezelni ezeket a számokat.

        </para>
    </section>        
                
    <section>
        <title>Biomorfok</title>
        
        <para>
            Megoldás forrása: https://github.com/ujhazibalazs/MagProg1/blob/master/biomorf.cpp
        </para>
<programlisting language="c"><![CDATA[
int
main ( int argc, char *argv[] )
{

    int width = 1920;
    int height = 1080;
    int iterationLimit = 255;
    double a = -1.9;
    double b = 0.7;
    double c = -1.3;
    double d = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        width = atoi ( argv[2] );
        height =  atoi ( argv[3] );
        iterationLimit =  atoi ( argv[4] );
        a = atof ( argv[5] );
        b = atof ( argv[6] );
        c = atof ( argv[7] );
        d = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./bio fajlnev width height n a b c d reC imC R" << std::endl;
        return -1;
    }

    png::image < png::rgb_pixel > image ( width, height );

    double dx = ( b - a ) / width;
    double dy = ( d - c ) / height;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int j = 0; j < height; ++j )
    {
        // k megy az oszlopokon

        for ( int k = 0; k < width; ++k )
        {

            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteration = 0;
            for (int i=0; i < iterationLimit; ++i)
            {

                //z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                //z_n=std::pow(z_n,z_n)+std::pow(z_n,6);
                z_n=(1.0-std::pow(z_n,3)/6.0)/std::pow((z_n-std::pow(z_n,2.0)/2.0),2)+cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteration = i;
                    break;
                }
            }

            image.set_pixel ( k, j,
                            png::rgb_pixel ( (iteration*20)%255, (iteration*40)%255, (iteration*60)%255 ));
        }

        int percentage = ( double ) j / ( double ) height * 100.0;
        std::cout << "\r" << percentage << "%" << std::flush;
    }

    image.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Tovább folytatjuk a Mandelbrot-os témakört. Ezzel a feladattal nem egészen 
            direkt a kapcsolata a Mandelbrot halmaznak, inkább a Julia halmazokkal
            lesz szoros rokonságban. A Mandelbrot halmaz tartalmazza az összes Julia
            halmazt. Ez abból következik, hogy a Julia halmaz esetén a c konstans, és
            a rácsot a z-vel járjuk be, viszont a Mandelbrot halmazban a c változóként
            szerepel, melyhez kiszámoljuk a z értékeket. Szóval mindig újabb és újabb 
            Julia halmazt számolunk ki vele. 
             A Biomorfokra Clifford Pickover talált rá, méghozzá egy Julia halmazt rajzoló
            prgramjának írása közben. A programja rejtett egy bugot, és emiatt egészen
            furcsa dolgokat produkált a program, melyre azt hitte, hogy valami természeti
            csodára lelt rá. Magáról a Biomorfokról, és a Pickover történetéről
            részletesebben olvashatsz
            <link xlink:href="https://bit.ly/2HCbCYs">itt</link>.
            Mi is ez alapján készítettük el a biomorf rajzoló programunkat, mely
            a Mandelbrot-os programra alapul, annak egy továbbfejlesztett verziója.

        </para>                        
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
  <programlisting language="c"><![CDATA[
#include <png++/image.hpp>
#include <png++/rgb_pixel.hpp>

#include <sys/times.h>
#include <iostream>


#define SIZE 600
#define ITERATION_LIMIT 32000

__device__ int
mandel (int k, int j)
{
  // Végigzongorázza a CUDA a szélesség x magasság rácsot:
  // most eppen a j. sor k. oszlopaban vagyunk

  // számítás adatai
  float a = -2.0, b = .7, c = -1.35, d = 1.35;
  int width = SIZE, height = SIZE, iterationLimit = ITERATION_LIMIT;

  // a számítás
  float dx = (b - a) / width;
  float dy = (d - c) / height;
  float reC, imC, reZ, imZ, ujreZ, ujimZ;
  // Hány iterációt csináltunk?
  int iteration = 0;

  // c = (reC, imC) a rács csomópontjainak
  // megfelelő komplex szám
  reC = a + k * dx;
  imC = d - j * dy;
  // z_0 = 0 = (reZ, imZ)
  reZ = 0.0;
  imZ = 0.0;
  iteration = 0;
  // z_{n+1} = z_n * z_n + c iterációk
  // számítása, amíg |z_n| < 2 vagy még
  // nem értük el a 255 iterációt, ha
  // viszont elértük, akkor úgy vesszük,
  // hogy a kiinduláci c komplex számra
  // az iteráció konvergens, azaz a c a
  // Mandelbrot halmaz eleme
  while (reZ * reZ + imZ * imZ < 4 && iteration < iterationLimit)
    {
      // z_{n+1} = z_n * z_n + c
      ujreZ = reZ * reZ - imZ * imZ + reC;
      ujimZ = 2 * reZ * imZ + imC;
      reZ = ujreZ;
      imZ = ujimZ;

      ++iteration;

    }
  return iteration;
}


/*
__global__ void
mandelkernel (int *buffer)
{

  int j = blockIdx.x;
  int k = blockIdx.y;

  buffer[j + k * SIZE] = mandel (j, k);

}
*/

__global__ void
mandelkernel (int *buffer)
{

  int tj = threadIdx.x;
  int tk = threadIdx.y;

  int j = blockIdx.x * 10 + tj;
  int k = blockIdx.y * 10 + tk;

  buffer[j + k * SIZE] = mandel (j, k);

}

void
cudamandel (int buffer[SIZE][SIZE])
{

  int *deviceImageBuffer;
  cudaMalloc ((void **) &deviceImageBuffer, SIZE * SIZE * sizeof (int));

  // dim3 grid (SIZE, SIZE);
  // mandelkernel <<< grid, 1 >>> (deviceImageBuffer);
  
  dim3 grid (SIZE / 10, SIZE / 10);
  dim3 tgrid (10, 10);
  mandelkernel <<< grid, tgrid >>> (deviceImageBuffer);  
  
  cudaMemcpy (buffer, deviceImageBuffer,
	      SIZE * SIZE * sizeof (int), cudaMemcpyDeviceToHost);
  cudaFree (deviceImageBuffer);

}

int
main (int argc, char *argv[])
{

  // Mérünk időt (PP 64)
  clock_t delta = clock ();
  // Mérünk időt (PP 66)
  struct tms tmsbuf1, tmsbuf2;
  times (&tmsbuf1);

  if (argc != 2)
    {
      std::cout << "Hasznalat: ./mandelpngc fajlnev";
      return -1;
    }

  int buffer[SIZE][SIZE];

  cudamandel (buffer);

  png::image < png::rgb_pixel > image (SIZE, SIZE);

  for (int j = 0; j < SIZE; ++j)
    {
      //sor = j;
      for (int k = 0; k < SIZE; ++k)
	{
	  image.set_pixel (k, j,
			 png::rgb_pixel (255 -
					 (255 * buffer[j][k]) / ITERATION_LIMIT,
					 255 -
					 (255 * buffer[j][k]) / ITERATION_LIMIT,
					 255 -
					 (255 * buffer[j][k]) / ITERATION_LIMIT));
	}
    }
  image.write (argv[1]);

  std::cout << argv[1] << " mentve" << std::endl;

  times (&tmsbuf2);
  std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
    + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

  delta = clock () - delta;
  std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

}

        
]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Tovább folytatjuk a MAndelbrot-halmazos programunk fejlesztését, ezúttal
            az Nvidia CUDA technológiáját hívjuk segítségül, mallyel jelentősen fel tudjuk
            gyorsítani a kép generálását. A tecknika lényege, hogy egy 600x600 darab blokkból
            álló gridet hozunk létre, és mindegy blokkhoz tartozik egy szál. Ezzel
            sikerül a program futását párhuzamosítani.
            A CUDA használatához nvidia GPU-ra van szükség, és telepíteni
            kell a <function>nvidia-cuda-toolkit</function>-et. 
            Mivel a gépemben nincsen videókártya ezt a foráskodót nem tudtam lefutatni csak utána olvasatm a dolgóknka.


        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
       <programlisting language="C++"><![CDATA[
        void mandel (int buffer[SIZE][SIZE]) {

    clock_t delta = clock ();
    struct tms tmsbuf1, tmsbuf2;
    times (&tmsbuf1);

    float a = -2.0, b = .7, c = -1.35, d = 1.35;
    int width = SIZE, height = SIZE, iterationLimit = ITERATION_LIMIT;

    // a számítás
    float dx = (b - a) / width;
    float dy = (d - c) / height;
    float reC, imC;
    
    int iteration = 0;
    
    
    
    for (int j = 0; j < height; ++j)
    {
        //sor = j;
        for (int k = 0; k < width; ++k)
        {
            
            reC = a + k * dx;
            imC = d - j * dy;
            std::complex<double> complexNum(reC,imC);
            std::complex<double> complexHelper(0,0);
          
            iteration = 0;
            
            while (std::abs(complexHelper) < 4 && iteration < iterationLimit)
            {
                
                complexHelper = complexHelper*complexHelper + complexNum;
                
                ++iteration;

            }

            buffer[j][k] = iteration;
        }
    }

    times (&tmsbuf2);
    std::cout <<tmsbuf2.tms_utime - tmsbuf1.tms_utime
              + tmsbuf2.tms_stime - tmsbuf1.tms_stime << "\n";

    delta = clock () - delta;
    std::cout << (float) delta / CLOCKS_PER_SEC << " sec\n";

}

int main (int argc, char *argv[])
{

    if (argc != 2)
    {
        std::cout << "Hasznalat: ./mandelpng fajlnev\n";
        return -1;
    }
    
    png::image < png::rgb_pixel > image(SIZE,SIZE);
    
    int buffer[SIZE][SIZE];

    mandel(buffer);

    for (int j = 0; j < SIZE; ++j)
    {
        //sor = j;
        for (int k = 0; k < SIZE; ++k)
        {
            image.set_pixel(k,j,png::rgb_pixel((255 - (255 * buffer[j][k]) / ITERATION_LIMIT)
                          ,(255 - (255 * buffer[j][k]) / ITERATION_LIMIT),
                           (255 - (255 * buffer[j][k]) / ITERATION_LIMIT)));
        }

    }
    image.write(argv[1]);

    std::cout << argv[1] <<" mentve\n";

}

    ]]></programlisting> 
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
            Telepíteni: sudo apt-get install libqt4-dev
            A program a QT GUI-t használja, ennek segítségével tudjuk elkészíteni a 
            Mandelbrot halmazt beutazó programunkat. Ez a GUI az egyik legertejedtebb
            garfikus interfésze a C++-nak, rengeteg tutorial van róla fent a neten. 
            Fordítás:
             Az szükséges 4 fájlnak egy mappában kell lennie. A mappában futtatni
             kell a <function>qmake -project</function> parancsot. Ez létre fog
            hozni egy <function>*.pro</function> fájlt. Ebbe a fájlba be kell
            írni a következőt: <function>QT += widgets</function> sort. Ezután futtatni kell
            a <function>qmake *.pro</function>.
            Ezután lesz a mappában
            egy <function>Makefile</function>, ezt kell majd használni. Ki 
            adjuk a <function>make</function> parancsot, mely létrehoz 
            egy bináris fájlt. Ezt pedig a szokásos módon futtatjuk.

        </para>

        
        
    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
            Megoldás forrása:  
        </para>
        <programlisting language="Java"><![CDATA[
public class MandelbrotIterációk implements Runnable{
    /** Mennyi időt várakozzunk két iteráció bemutatása között? */
    private int várakozás;
    // Kissé igaz redundánsan, s nem szépen, de kényelmesen:
    private MandelbrotHalmazNagyító nagyító;
    private int j, k;
    private double a, b, c, d;
    private  int szélesség, magasság;
    private java.awt.image.BufferedImage kép;
    /**
     * Létrehoz egy iterációkat vizsgáló <code>MandelbrotIterációk</code>
     * szál objektumot egy adott <code>MandelbrotHalmaznagyító</code>
     * objektumhoz.
     *
     * @param      nagyító      egy <code>MandelbrotHalmazNagyító</code> objektum
     * @param      várakozás    várakozási idő
     */
    public MandelbrotIterációk(MandelbrotHalmazNagyító nagyító, int várakozás) {        
        this.nagyító = nagyító;
        this.várakozás = várakozás;
        j = nagyító.getY();
        k = nagyító.getX();
        a = nagyító.getA();
        b = nagyító.getB();
        c = nagyító.getC();
        d = nagyító.getD();
        kép = nagyító.kép();
        szélesség  = nagyító.getSz();
        magasság = nagyító.getM();
    }
    /** Az vizsgált pontból induló iterációk bemutatása. */
    public void run() {
        /* Az alábbi kód javarészt a MandelbrotHalmaz.java számolást 
         végző run() módszeréből származik, hiszen ugyanazt csináljuk,
         csak most nem a hálón megyünk végig, hanem a háló adott a
         példányosításunkkor az egérmutató mutatta csomópontjában (ennek
         felel meg a c kompelx szám) számolunk, tehát a két külső for 
         ciklus nem kell. */
        // A [a,b]x[c,d] tartományon milyen sűrű a
        // megadott szélesség, magasság háló:
        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        // Hány iterációt csináltunk?
        int iteráció = 0;
        // c = (reC, imC) a háló rácspontjainak
        // megfelelő komplex szám
        reC = a+k*dx;
        imC = d-j*dy;
        // z_0 = 0 = (reZ, imZ)
        reZ = 0;
        imZ = 0;
        iteráció = 0;
        // z_{n+1} = z_n * z_n + c iterációk
        // számítása, amíg |z_n| < 2 vagy még
        // nem értük el a 255 iterációt, ha
        // viszont elértük, akkor úgy vesszük,
        // hogy a kiinduláci c komplex számra
        // az iteráció konvergens, azaz a c a
        // Mandelbrot halmaz eleme
        while(reZ*reZ + imZ*imZ < 4 && iteráció < 255) {
            // z_{n+1} = z_n * z_n + c
            ujreZ = reZ*reZ - imZ*imZ + reC;
            ujimZ = 2*reZ*imZ + imC;
         
            // az iteráció (reZ, imZ) -> (ujreZ, ujimZ)
            // ezt az egyenest kell kirajzolnunk, de most
            // a komplex számokat vissza kell transzformálnunk
            // a rács oszlop, sor koordinátájává:
            java.awt.Graphics g = kép.getGraphics();
            g.setColor(java.awt.Color.WHITE);
            g.drawLine(
                    (int)((reZ - a)/dx),
                    (int)((d - imZ)/dy),
                    (int)((ujreZ - a)/dx),
                    (int)((d - ujimZ)/dy)
                    );
            g.dispose();
            nagyító.repaint();
            
            reZ = ujreZ;
            imZ = ujimZ;
            
            ++iteráció;
            // Várakozunk, hogy közben csodálhassuk az iteráció
            // látványát:
            try {
                Thread.sleep(várakozás);
            } catch (InterruptedException e) {}
        }
    }    
}       
        ]]></programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
            Az előző feladatban készített nagyító Java implementációját
            kell most elkészíteni. A forrás egy kicsit bugos, mivel amikor
            nagyítasz. akkor új ablakban nyílik meg a nagyítás, melynek
            mérete a kijelölt terület függvényében változik. Érdekesség
            ebben a Java programban már includálva van
            másik java program, a <filename>MandelbrotHalmaz.java</filename>.
            Ezt a következő sorral érjük el:
            <programlisting language="java">
                public class MandelbrotHalmazNagyító extends MandelbrotHalmaz
            </programlisting>
            A Javaban nincs a már megszokott <function>#include</function>, helyette az <function>import</function>-ot
            vagy jelen esetben az <function>extends</function>-et használjuk.
        </para>
        
    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
